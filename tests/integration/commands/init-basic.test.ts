import { describe, expect, mock, spyOn, test } from 'bun:test';
import { existsSync, readFileSync } from 'node:fs';
import { join } from 'node:path';
import type { Domain } from '@/types';
import { getTestDOTSX } from '../setup/test-constants';
import { withIntegrationEnvironment } from '../setup/test-environment';

describe('Init Command Basic Integration Tests', () => {
  test('should create basic dotsx directory structure', async () => {
    await withIntegrationEnvironment(async () => {
      delete require.cache[require.resolve('../../../src/commands/init')];
      delete require.cache[require.resolve('../../../src/lib/system')];
      delete require.cache[require.resolve('../../../src/lib/constants')];

      const { initCommand } = await import('../../../src/commands/init');
      const { DotsxInfoLib, SystemLib } = await import('../../../src/lib/system');

      const consoleSpy = spyOn(console, 'log').mockImplementation(() => {});
      const errorSpy = spyOn(console, 'error').mockImplementation(() => {});
      const isInitializedSpy = spyOn(DotsxInfoLib, 'isInitialized').mockReturnValue(false);
      const getCurrentOsTypeSpy = spyOn(SystemLib, 'getOsInfo').mockReturnValue({
        platform: 'linux',
        family: 'linux',
        distro: 'debian',
        release: '12',
      });

      const mockSelect = mock(() => Promise.resolve('debian'));
      const mockMultiselect = mock(() => Promise.resolve([]));
      const selectSpy = spyOn(await import('@clack/prompts'), 'select').mockImplementation(mockSelect as any);
      const multiselectSpy = spyOn(await import('@clack/prompts'), 'multiselect').mockImplementation(mockMultiselect);

      const mockExecSync = mock(() => '');
      const execSyncSpy = spyOn(await import('node:child_process'), 'execSync').mockImplementation(mockExecSync as any);

      const DOTSX = getTestDOTSX();

      await initCommand.execute();

      expect(existsSync(DOTSX.BIN.PATH)).toBe(true);
      expect(existsSync(join(DOTSX.OS.PATH, 'debian'))).toBe(true);

      expect(existsSync(DOTSX.BIN.ALIAS)).toBe(true);

      expect(existsSync(DOTSX.OS.DEBIAN.APT)).toBe(true);
      expect(existsSync(DOTSX.OS.DEBIAN.SNAP)).toBe(true);

      const aptContent = readFileSync(DOTSX.OS.DEBIAN.APT, 'utf-8');
      expect(aptContent).toContain('# APT packages');


      expect(consoleSpy).toHaveBeenCalledWith('❌ DotX not initialized');
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('✅ Bin directory created'));

      expect(errorSpy).not.toHaveBeenCalled();

      consoleSpy.mockRestore();
      errorSpy.mockRestore();
      isInitializedSpy.mockRestore();
      getCurrentOsTypeSpy.mockRestore();
      selectSpy.mockRestore();
      multiselectSpy.mockRestore();
      execSyncSpy.mockRestore();
    });
  });

  test('should handle already initialized state', async () => {
    await withIntegrationEnvironment(async () => {
      const { initCommand } = await import('../../../src/commands/init');
      const { FileLib } = await import('../../../src/lib/file');

      const DOTSX = getTestDOTSX();

      FileLib.createDirectory(DOTSX.BIN.PATH);

      const consoleSpy = spyOn(console, 'log').mockImplementation(() => {});
      const { DotsxInfoLib } = await import('../../../src/lib/system');
      const isInitializedSpy = spyOn(DotsxInfoLib, 'isInitialized').mockReturnValue(true);

      const mockSelect = mock(() => Promise.resolve('debian'));
      const mockMultiselect = mock(() => Promise.resolve([]));
      const selectSpy = spyOn(await import('@clack/prompts'), 'select').mockImplementation(mockSelect as any);
      const multiselectSpy = spyOn(await import('@clack/prompts'), 'multiselect').mockImplementation(mockMultiselect);

      await initCommand.execute();

      // Should show already initialized message
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('✅ DotX initialized'));

      consoleSpy.mockRestore();
      isInitializedSpy.mockRestore();
      selectSpy.mockRestore();
      multiselectSpy.mockRestore();
    });
  });

  test('should create OS-specific package files', async () => {
    await withIntegrationEnvironment(async () => {
      const { initCommand } = await import('../../../src/commands/init');

      // Create a test domain with proper structure that matches how real domains work
      const DOTSX = getTestDOTSX();

      const testDomain: Domain = {
        name: 'debian',
        type: 'os' as const,
        distro: 'debian',
        availableOs: ['linux'],
        packageManagers: {
          apt: {
            configPath: DOTSX.OS.DEBIAN.APT,
            install: 'sudo apt install -y %s',
            remove: 'sudo apt remove -y %s',
            status: 'dpkg -l | grep "^ii" | grep -w " %s "',
            defaultContent: '# APT packages\n# Generated by dotsx\n# Add package names, one per line\n# Lines starting with # are ignored\n'
          },
          snap: {
            configPath: DOTSX.OS.DEBIAN.SNAP,
            install: 'sudo snap install %s',
            remove: 'sudo snap remove %s',
            status: 'snap list | grep -w "%s "',
            defaultContent: '# Snap packages\n# Generated by dotsx\n# Add package names, one per line\n# Lines starting with # are ignored\n'
          }
        }
      };

      const consoleSpy = spyOn(console, 'log').mockImplementation(() => {});

      await initCommand.initOs(testDomain);

      expect(existsSync(DOTSX.OS.DEBIAN.APT)).toBe(true);
      expect(existsSync(DOTSX.OS.DEBIAN.SNAP)).toBe(true);

      const aptContent = readFileSync(DOTSX.OS.DEBIAN.APT, 'utf-8');
      const snapContent = readFileSync(DOTSX.OS.DEBIAN.SNAP, 'utf-8');

      expect(aptContent).toContain('# APT packages');
      expect(snapContent).toContain('# Snap packages');

      consoleSpy.mockRestore();
    });
  });

  test('should handle error scenarios gracefully', async () => {
    await withIntegrationEnvironment(async () => {
      const { initCommand } = await import('../../../src/commands/init');

      const errorSpy = spyOn(console, 'error').mockImplementation(() => {});
      const { DotsxInfoLib } = await import('../../../src/lib/system');
      const isInitializedSpy = spyOn(DotsxInfoLib, 'isInitialized').mockImplementation(() => {
        throw new Error('Test error');
      });

      await initCommand.execute();

      expect(errorSpy).toHaveBeenCalledWith('❌ Error during initialization: Error: Test error');

      errorSpy.mockRestore();
      isInitializedSpy.mockRestore();
    });
  });
});